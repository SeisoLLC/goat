---
# https://taskfile.dev

version: "3"

set:
  - nounset
  - errexit
  - pipefail

vars:
  LOCAL_PLATFORM:
    sh: |
      os="linux"
      arch="$(uname -m)"

      case ${arch} in
        # AMD64
        x86_64)  echo "${os}/amd64" ;;
        amd64)   echo "${os}/amd64" ;;

        # ARM64
        aarch64) echo "${os}/arm64" ;;
        arm64)   echo "${os}/arm64" ;;
      esac

tasks:
  lock:
    desc: Generate a Pipfile.lock if Pipfile changed from last run
    dir: ../../..
    internal: true
    sources:
      - Pipfile
    generates:
      - Pipfile.lock
    cmds:
      - pipenv lock

  lint:
    desc: Run the linter(s); paved road projects use the Seiso goat ðŸ
    platforms: [linux, darwin]
    vars:
      INPUT_AUTO_FIX: '{{.INPUT_AUTO_FIX | default ""}}'
      INPUT_DISABLE_MYPY: '{{.INPUT_DISABLE_MYPY | default ""}}'
      INPUT_EXCLUDE: '{{.INPUT_EXCLUDE | default ""}}'
      INPUT_LOG_LEVEL: '{{.INPUT_LOG_LEVEL | default ""}}'
    preconditions:
      - sh: |
          docker pull seiso/goat:latest || \
            echo "Failed to pull the goat, continuing anyway..."
    cmds:
      - pwd
      - |
        docker run --env INPUT_AUTO_FIX="{{.INPUT_AUTO_FIX}}" \
                   --env INPUT_DISABLE_MYPY="{{.INPUT_DISABLE_MYPY}}" \
                   --env INPUT_EXCLUDE="{{.INPUT_EXCLUDE}}" \
                   --env INPUT_LOG_LEVEL="{{.INPUT_LOG_LEVEL}}" \
                   --rm -v "{{.ROOT_DIR}}:/goat" seiso/goat:latest

  build:
    desc: Build the project; docker images, compiled binaries, etc.
    platforms: [linux, darwin]
    dir: ../../..
    requires:
      vars: ['VERSION']
    vars:
      VERSION: '{{.VERSION}}'
      PLATFORM: '{{.PLATFORM | default .LOCAL_PLATFORM}}'
      PUBLISH: '{{.PUBLISH | default "false"}}'
      DOCKER_BUILDX_CUSTOM_ARGS: '{{.DOCKER_BUILDX_CUSTOM_ARGS | default ""}}'
      TAG_COMMIT_HASH:
        sh: git rev-list -1 "v{{.VERSION}}"
      COMMIT_HASH:
        sh: git rev-parse HEAD
      COMMIT_HASH_SHORT:
        sh: git rev-parse --short HEAD
      REPO_TAGS:
        sh: git tag -l
      BUILD_VERSION:
        sh: |
          pipenv run python -c '
          version_string = "{{.VERSION}}"
          repo_tags = []
          {{range $tag := .REPO_TAGS | splitLines -}}
          repo_tags.append("{{$tag}}")
          {{end}}
          if (
              version_string in repo_tags
              and "{{.TAG_COMMIT_HASH}}" == "{{.COMMIT_HASH}}"
          ):
              build_version = "{{.VERSION}}"
          else:
              build_version = f"{{.VERSION}}-{{.COMMIT_HASH_SHORT}}"
          print(build_version)'
    cmds:
      # We only load when the provided platform equals the detected local platform. This is for two reasons:
      # 1. We assume you don't want to load a cross-platform build
      # 2. Currently (2023-07-30) you cannot --load if you are building multiple platforms
      #
      # Also, we make load and push mutually exclusive because docker says "ERROR: push and load may not be set together at the moment"
      #
      # Finally, we combine this all together in one `docker buildx build` with `--push` when {{.PUBLISH}} is true so that it handles the multi-platform
      # manifest creation for us. Otherwise we'd need to push per-platform tags and artisanally craft the manifest with `crane`, `docker manifest`, or similar
      - |
        docker buildx build --platform="{{.PLATFORM}}" \
                            {{if eq .PUBLISH "true"}}--push{{else if eq .PLATFORM .LOCAL_PLATFORM}}--load{{end}} \
                            {{if .DOCKER_BUILDX_CUSTOM_ARGS}}{{.DOCKER_BUILDX_CUSTOM_ARGS}}{{end}} \
                            --build-arg VERSION="{{.BUILD_VERSION}}" \
                            --build-arg COMMIT_HASH="{{.COMMIT_HASH}}" \
                            --tag {{.IMAGE_NAME}}:latest \
                            --tag {{.IMAGE_NAME}}:{{.BUILD_VERSION}} \
                            "${PWD}/."
      - '{{if ne .PLATFORM .LOCAL_PLATFORM}}{{if ne .PUBLISH "true"}}echo "WARNING: Avoided loading {{.IMAGE_NAME}}:latest and {{.IMAGE_NAME}}:{{.BUILD_VERSION}} into your docker daemon because you built a cross-platform image of {{.PLATFORM}}"{{end}}{{end}}'

  release:
    desc: Cut a project release
    # This is a relative path which should place us back into the calling repo, assuming this is called from a goat/Task/*/Taskfile.yml.
    dir: ../../..
    requires:
      vars: ['PYTHON_VERSION']
    vars:
      PYTHON_VERSION: '{{.PYTHON_VERSION}}'
      RELEASE_TYPE: "{{.CLI_ARGS}}"
      DATE_INFO: '{{now | date "2006.01"}}'
      REPO_TAGS:
        sh: git tag -l
      VERSIONING:
        sh: grep versioning setup.cfg | cut -d '"' -f 2
      RELEASE_VERSION:
        sh: |
          docker run --rm \
                     -v "${PWD}:/usr/src/app" \
                     -w /usr/src/app \
                     python:{{.PYTHON_VERSION}}-slim \
                     python -c '
          import re
          pattern = re.compile(r"v2[0-1][0-9]{2}.(0[0-9]|1[0-2]).[0-9]{2}")
          repo_tags = []
          {{range $tag := .REPO_TAGS | splitLines -}}
          repo_tags.append("{{$tag}}")
          {{end}}
          for tag in reversed(repo_tags):
              if pattern.fullmatch(tag):
                  latest_release = tag
                  break
              else:
                  latest_release = None
          if latest_release and "{{.DATE_INFO}}" == latest_release[1:8]:
              increment = str(int(latest_release[9:]) + 1).zfill(2)
          else:
              increment = "01"
          new_version = f"{{.DATE_INFO}}.{increment}"
          print(new_version)'
    preconditions:
      - sh: test `git status -s | wc -w` = "0"
        msg: "There are untracked files, please commit before creating a release."
    cmds:
      - task: pipeline-git-init
      # Better conditional syntax is pending https://github.com/go-task/task/issues/608
      - >
        {{if eq .VERSIONING "CalVer"}}pipenv run bumpversion --config-file setup.cfg --new-version {{.RELEASE_VERSION}}
        unusedpart{{else if eq .VERSIONING "SemVer"}}pipenv run bumpversion --config-file setup.cfg {{.RELEASE_TYPE}}{{end}}

  publish:
    desc: Publish the project artifacts; docker images, compiled binaries, etc.
    requires:
      vars: ['VERSION']
    cmds:
      - task: build
        vars:
          PUBLISH: 'true'
          VERSION: '{{.VERSION}}'
          PLATFORM: '{{.PLATFORM | default .LOCAL_PLATFORM}}'
          DOCKER_BUILDX_CUSTOM_ARGS: '{{.DOCKER_BUILDX_CUSTOM_ARGS | default ""}}'

  update:
    desc: >
      Update the project dev and runtime dependencies, and other misc components
    # This is a relative path which should place us back into the calling repo, assuming this is called from a goat/Task/*/Taskfile.yml.
    dir: ../../..
    cmds:
      - task: lock
      - git submodule update --remote
      - pipenv run pre-commit autoupdate --bleeding-edge --freeze --jobs 4
      - >
        docker run --rm -v "${PWD}:/usr/src/app" -w /usr/src/app python:{{.PYTHON_VERSION}}-slim /bin/bash
        -c "python3 -m pip install --upgrade pipenv &>/dev/null && pipenv update"

  pipeline-git-init:
    desc: Initialize git configs in the pipeline
    status:
      - '{{if eq .GITHUB_ACTIONS "true"}}exit 1{{end}}'
    cmds:
      - git config --global user.name "Seiso Automation"
      - git config --global user.email "automation@seisollc.com"
      - git config --global credential.helper '!f() { sleep 1 && echo "username=${GITHUB_USER}" && echo "password=${GITHUB_PAT}"; }; f'

  pipeline-docker-multiplatform-init:
    desc: Setup docker in a GitHub Actions pipeline for multiplatform builds
    status:
      - '{{if eq .GITHUB_ACTIONS "true"}}exit 1{{end}}'
    cmds:
      # This fixes an "ERROR: Multiple platforms feature is currently not supported for docker driver" pipeline error
      - docker buildx create --name multiplatform --driver docker-container --use

  clean:
    desc: Clean up build artifacts, cache files/directories, temp files, etc.
    cmds:
      - find {{.ROOT_DIR}} -type f -name '.DS_Store' -delete
      - find {{.ROOT_DIR}} -type f -name '.Thumbs.db' -delete
      - find {{.ROOT_DIR}} -type d -name '__pycache__' -exec rm -rf {} +
      - find {{.ROOT_DIR}} -type d -name '.mypy_cache' -exec rm -rf {} +
      - find {{.ROOT_DIR}} -type d -name '.pytest_cache' -exec rm -rf {} +
      - find {{.ROOT_DIR}} -type f -name '*.pyc' -delete
      - find {{.ROOT_DIR}} -type d -name '.ruff_cache' -exec rm -rf {} +
      - find {{.ROOT_DIR}} -type d -name '.task' -exec rm -rf {} +
